{"version":1,"ops":[{"type":1,"author":{"id":"361b1e995cac5cbfbe4810e239fe8802ce1e20c3"},"timestamp":1617292296,"metadata":{"github-id":"MDU6SXNzdWU4NDg1ODc0OTc=","github-url":"https://github.com/rurban/dieharder/issues/13","origin":"github"},"title":"Test PRVHASH 3.3","message":"Could you test minimal PRVHASH PRNG with your DieHarder setting?\n\n```\n#include \"prvhash_core.h\"\n#include \u003cstdio.h\u003e\n\nint main()\n{\n\tuint64_t Seed = 0;\n\tuint64_t lcg = 0;\n\tuint64_t Hash = 0;\n\n\tuint64_t v = 0;\n\tuint64_t i;\n\n\tfor( i = 0; i \u003c ( 1ULL \u003c\u003c 27 ); i++ )\n\t{\n\t\tv = prvhash_core64( \u0026Seed, \u0026lcg, \u0026Hash );\n\t}\n\n\tprintf( \"%llu\\n\", v );\n}\n```\n\nAnother arrangement (I call it \"Fused PRNG\") worth testing, because it's fast (0.41cycles/byte) without SIMD: here, v, v2, v3 (24 bytes combined) are a single continuous PRNG output per round, it's structurally similar to SIMD and can be potentially ported to AVX-512.\n```\n#include \"prvhash_core.h\"\n#include \u003cstdio.h\u003e\n\nint main()\n{\n\tuint64_t Seed = 0;\n\tuint64_t lcg = 0;\n\tuint64_t Hash = 0;\n\tuint64_t Seed2 = 0;\n\tuint64_t lcg2 = 0;\n\tuint64_t Hash2 = 0;\n\tuint64_t Seed3 = 0;\n\tuint64_t lcg3 = 0;\n\tuint64_t Hash3 = 0;\n\tuint64_t Hash4 = 0;\n\n\tuint64_t v = 0;\n\tuint64_t v2 = 0;\n\tuint64_t v3 = 0;\n\n\tuint64_t i;\n\n\tfor( i = 0; i \u003c ( 1ULL \u003c\u003c 27 ); i++ )\n\t{\n\t\tv = prvhash_core64( \u0026Seed, \u0026lcg, \u0026Hash );\n\t\tv2 = prvhash_core64( \u0026Seed2, \u0026lcg2, \u0026Hash2 );\n\t\tv3 = prvhash_core64( \u0026Seed3, \u0026lcg3, \u0026Hash3 );\n\n\t\tuint64_t t = Hash;\n\t\tHash = Hash2;\n\t\tHash2 = Hash3;\n\t\tHash3 = Hash4;\n\t\tHash4 = t;\n\t}\n\n\tprintf( \"%llu %llu %llu\\n\", v, v2, v3 );\n}\n```","files":null}]}